{
  "version": 3,
  "sources": ["../../../app/utils/user.ts"],
  "sourcesContent": ["// REMIX HMR BEGIN\nimport * as __hmr__ from \"remix:hmr\";\nif (import.meta) {\nimport.meta.hot = __hmr__.createHotContext(\n//@ts-expect-error\n\"app/utils/user.ts\"\n);\nimport.meta.hot.lastModified = \"1713997433063.7124\";\n}\n// REMIX HMR END\n\nimport { useRouteLoaderData } from \"@remix-run/react\";\n\nimport type { SerializeFrom } from \"@remix-run/node\";\n\nimport type { loader as rootLoader } from \"#app/root.tsx\";\n\nfunction isUser(\n  user: unknown,\n): user is SerializeFrom<typeof rootLoader>[\"user\"] {\n  return (\n    !!user &&\n    typeof user === \"object\" &&\n    \"id\" in user &&\n    typeof user.id === \"string\"\n  );\n}\n\nexport function useOptionalUser() {\n  const data = useRouteLoaderData<typeof rootLoader>(\"root\");\n  if (!data || !isUser(data.user)) {\n    return undefined;\n  }\n  return data.user;\n}\n\nexport function useUser() {\n  const maybeUser = useOptionalUser();\n  if (!maybeUser) {\n    throw new Error(\n      \"No user found in root loader, but user is required by useUser. If user is optional, try useOptionalUser instead.\",\n    );\n  }\n  return maybeUser;\n}\n\ntype Action = \"create\" | \"read\" | \"update\" | \"delete\";\ntype Entity = \"user\" | \"note\";\ntype Access = \"own\" | \"any\" | \"own,any\" | \"any,own\";\nexport type PermissionString =\n  | `${Action}:${Entity}`\n  | `${Action}:${Entity}:${Access}`;\n\nexport function parsePermissionString(permissionString: PermissionString) {\n  const [action, entity, access] = permissionString.split(\":\") as [\n    Action,\n    Entity,\n    Access | undefined,\n  ];\n\n  return {\n    action,\n    entity,\n    access: access ? (access.split(\",\") as Access[]) : undefined,\n  };\n}\n\nexport function userHasPermission(\n  user: Pick<ReturnType<typeof useUser>, \"roles\"> | null | undefined,\n  permission: PermissionString,\n) {\n  if (!user) {\n    return false;\n  }\n\n  const { action, entity, access } = parsePermissionString(permission);\n\n  return user.roles.some((role) =>\n    role.permissions.some(\n      (permission) =>\n        permission.entity === entity &&\n        permission.action === action &&\n        (!access || access.includes(permission.access)),\n    ),\n  );\n}\n\nexport function userHasRole(\n  user: Pick<ReturnType<typeof useUser>, \"roles\"> | null,\n  role: string,\n) {\n  if (!user) {\n    return false;\n  }\n\n  return user.roles.some((r) => r.name === role);\n}\n"],
  "mappings": ";;;;;;;;AAEA,IAAI,aAAa;AACjB,cAAY,MAAc;AAAA;AAAA,IAE1B;AAAA,EACA;AACA,cAAY,IAAI,eAAe;AAC/B;AASA,SAAS,OACP,MACkD;AAClD,SACE,CAAC,CAAC,QACF,OAAO,SAAS,YAChB,QAAQ,QACR,OAAO,KAAK,OAAO;AAEvB;AAEO,SAAS,kBAAkB;AAChC,QAAM,OAAO,mBAAsC,MAAM;AACzD,MAAI,CAAC,QAAQ,CAAC,OAAO,KAAK,IAAI,GAAG;AAC/B,WAAO;AAAA,EACT;AACA,SAAO,KAAK;AACd;AAEO,SAAS,UAAU;AACxB,QAAM,YAAY,gBAAgB;AAClC,MAAI,CAAC,WAAW;AACd,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AASO,SAAS,sBAAsB,kBAAoC;AACxE,QAAM,CAAC,QAAQ,QAAQ,MAAM,IAAI,iBAAiB,MAAM,GAAG;AAM3D,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,QAAQ,SAAU,OAAO,MAAM,GAAG,IAAiB;AAAA,EACrD;AACF;AAEO,SAAS,kBACd,MACA,YACA;AACA,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AAEA,QAAM,EAAE,QAAQ,QAAQ,OAAO,IAAI,sBAAsB,UAAU;AAEnE,SAAO,KAAK,MAAM;AAAA,IAAK,CAAC,SACtB,KAAK,YAAY;AAAA,MACf,CAACA,gBACCA,YAAW,WAAW,UACtBA,YAAW,WAAW,WACrB,CAAC,UAAU,OAAO,SAASA,YAAW,MAAM;AAAA,IACjD;AAAA,EACF;AACF;",
  "names": ["permission"]
}
